/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.calcite.rel.metadata

import org.apache.calcite.rel.RelNode

/**
 * Base class for the RelMetadataQuery that uses the metadata handler class
 * generated by the Janino.
 *
 *
 * To add a new implementation to this interface, follow
 * these steps:
 *
 *
 *  1. Extends [RelMetadataQuery] (name it MyRelMetadataQuery for example)
 * to reuse the Calcite builtin metadata query interfaces. In this class, define all the
 * extended Handlers for your metadata and implement the metadata query interfaces.
 *  1. Write your customized provider class `RelMdXyz`. Follow
 * the pattern from an existing class such as [RelMdColumnOrigins],
 * overloading on all of the logical relational expressions to which the query
 * applies.
 *  1. Add a `SOURCE` static member to each of your provider class, similar to
 * [RelMdColumnOrigins.SOURCE].
 *  1. Extends [DefaultRelMetadataProvider] (name it MyRelMetadataProvider for example)
 * and supplement the "SOURCE"s into the builtin list
 * (This is not required, use [ChainedRelMetadataProvider] to chain your customized
 * "SOURCE"s with default ones also works).
 *  1. Set `MyRelMetadataProvider` into the cluster instance.
 *  1. Use
 * [org.apache.calcite.plan.RelOptCluster.setMetadataQuerySupplier]
 * to set the metadata query [Supplier] into the cluster instance. This [Supplier]
 * should return a **fresh new** instance.
 *  1. Use the cluster instance to create
 * [org.apache.calcite.sql2rel.SqlToRelConverter].
 *  1. Query your metadata within [org.apache.calcite.plan.RelOptRuleCall] with the
 * interfaces you defined in `MyRelMetadataQuery`.
 *
 */
class RelMetadataQueryBase @SuppressWarnings("deprecation") protected constructor(@Nullable provider: MetadataHandlerProvider?) {
    //~ Instance fields --------------------------------------------------------
    /** Set of active metadata queries, and cache of previous results.  */
    val map: Table<RelNode, Object, Object> = HashBasedTable.create()

    @Nullable
    private val metadataHandlerProvider: MetadataHandlerProvider?

    @Deprecated // to be removed before 2.0
    @Nullable
    val metadataProvider: JaninoRelMetadataProvider?

    //~ Constructors -----------------------------------------------------------
    @Deprecated // to be removed before 2.0
    protected constructor(@Nullable metadataProvider: JaninoRelMetadataProvider?) : this(metadataProvider as MetadataHandlerProvider?) {
    }

    init {
        metadataHandlerProvider = provider
        metadataProvider = if (provider is JaninoRelMetadataProvider) provider else null
    }
    //~ Methods ----------------------------------------------------------------
    /** Re-generates the handler for a given kind of metadata, adding support for
     * `class_` if it is not already present.  */
    @Deprecated // to be removed before 2.0
    protected fun <M : Metadata?, H : MetadataHandler<M>?> revise(
        class_: Class<out RelNode?>?,
        def: MetadataDef<M>
    ): H {
        return revise<MetadataHandler<*>>(def.handlerClass) as H
    }

    /** Re-generates the handler for a given kind of metadata, adding support for
     * `class_` if it is not already present.  */
    protected fun <H : MetadataHandler<*>?> revise(def: Class<H>?): H {
        return getMetadataHandlerProvider().revise(def)
    }

    private fun getMetadataHandlerProvider(): MetadataHandlerProvider {
        requireNonNull(metadataHandlerProvider, "metadataHandlerProvider")
        return castNonNull(metadataHandlerProvider)
    }

    /**
     * Provide a handler for the requested metadata class.
     * @param handlerClass The handler interface expected
     * @param <MH> The metadata type the handler relates to.
     * @return The handler implementation.
    </MH> */
    protected fun <MH : MetadataHandler<*>?> handler(handlerClass: Class<MH>?): MH {
        return getMetadataHandlerProvider().handler(handlerClass)
    }

    /**
     * Removes cached metadata values for specified RelNode.
     *
     * @param rel RelNode whose cached metadata should be removed
     * @return true if cache for the provided RelNode was not empty
     */
    fun clearCache(rel: RelNode?): Boolean {
        val row: Map<Object, Object> = map.row(rel)
        if (row.isEmpty()) {
            return false
        }
        row.clear()
        return true
    }

    companion object {
        //~ Static fields/initializers ---------------------------------------------
        val THREAD_PROVIDERS: ThreadLocal<JaninoRelMetadataProvider> = ThreadLocal()
        @Deprecated
        protected fun <H> initialHandler(handlerClass: Class<H>): H {
            return handlerClass.cast(
                Proxy.newProxyInstance(
                    RelMetadataQuery::class.java.getClassLoader(),
                    arrayOf<Class>(handlerClass)
                ) { proxy, method, args ->
                    val r: RelNode = requireNonNull(args.get(0) as RelNode, "(RelNode) args[0]")
                    throw NoHandler(r.getClass())
                })
        }
    }
}
