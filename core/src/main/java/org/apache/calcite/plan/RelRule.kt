/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.calcite.plan

import org.apache.calcite.rel.RelNode
import org.apache.calcite.rel.core.RelFactories
import org.apache.calcite.tools.RelBuilderFactory
import com.google.common.collect.ImmutableList
import org.immutables.value.Value
import java.util.ArrayList
import java.util.List
import java.util.Locale
import java.util.Objects
import java.util.function.BiConsumer
import java.util.function.Function
import java.util.function.Predicate

/**
 * Rule that is parameterized via a configuration.
 *
 *
 * Eventually (before Calcite version 2.0), this class will replace
 * [RelOptRule]. Constructors of `RelOptRule` are deprecated, so new
 * rule classes should extend `RelRule`, not `RelOptRule`.
 * Next, we will deprecate `RelOptRule`, so that variables that reference
 * rules will be of type `RelRule`.
 *
 *
 * **Guidelines for writing rules**
 *
 *
 * 1. If your rule is a sub-class of
 * [org.apache.calcite.rel.convert.ConverterRule]
 * and does not need any extra properties,
 * there's no need to create an `interface Config` inside your class.
 * In your class, create a constant
 * `public static final Config DEFAULT_CONFIG`. Goto step 5.
 *
 *
 * 2. If your rule is not a sub-class of
 * [org.apache.calcite.rel.convert.ConverterRule],
 * create an inner `interface Config extends RelRule.Config` and
 * annotate it with `@Value.Immutable`. Note, if your inner class
 * is two levels deep (e.g. top-level Rule with Config inside), we recommend
 * you annotate the outer class with `@Value.Enclosing` which will
 * instruct the annotation processor to put your generated value class
 * inside a new Immutable outer class. If your rule is three levels deep,
 * the best thing to do is give your class a unique name to avoid any
 * generated code class name overlaps.
 * Implement [toRule][Config.toRule] using a `default` method:
 *
 * <blockquote>
 * `
 * &#x40;Override default CsvProjectTableScanRule toRule() {<br></br>
 * &nbsp;&nbsp;return new CsvProjectTableScanRule(this);<br></br>
 * }
` *
</blockquote> *
 *
 *
 * 3. For each configuration property, create a pair of methods in your
 * `Config` interface. For example, for a property `foo` of type
 * `int`, create methods `foo` and `withFoo`:
 *
 * <blockquote><pre>`
 * &#x2f;** Returns foo. *&#x2f;
 * int foo();
 *
 * &#x2f;** Sets {&#x40;link #foo}. *&#x2f;
 * Config withFoo(int x);
`</pre></blockquote> *
 *
 *
 * 4. In your `Config` interface, create a `DEFAULT` constant
 * that represents the most typical configuration of your rule. This default
 * will leverage the Immutables class generated by the Annotation Processor
 * based on the annotation you provided above. For example,
 * `CsvProjectTableScanRule.Config` has the following:
 *
 * <blockquote><pre>`
 * Config DEFAULT = ImmutableCsvProjectTableScanRule.Config.builder()
 * .withOperandSupplier(b0 ->
 * b0.operand(LogicalProject.class).oneInput(b1 ->
 * b1.operand(CsvTableScan.class).noInputs()))
 * .build();
`</pre></blockquote> *
 *
 *
 * 5. Do not create an `INSTANCE` constant inside your rule.
 * Instead, create a named instance of your rule, with default configuration,
 * in a holder class. The holder class must not be a sub-class of
 * `RelOptRule` (otherwise cyclic class-loading issues may arise).
 * Generally it will be called `*Xxx*Rules`, for example
 * `CsvRules`. The rule instance is named after your rule, and is based
 * on the default config (`Config.DEFAULT`, or `DEFAULT_CONFIG` for
 * converter rules):
 *
 * <blockquote><pre>`
 * &#x2f;** Rule that matches a {&#x40;code Project} on a
 * * {&#x40;code CsvTableScan} and pushes down projects if possible. *&#x2f;
 * public static final CsvProjectTableScanRule PROJECT_SCAN =
 * CsvProjectTableScanRule.Config.DEFAULT.toRule();
`</pre></blockquote> *
 *
 * @param <C> Configuration type
</C> */
abstract class RelRule<C : RelRule.Config?>
/** Creates a RelRule.  */ protected constructor(val config: C) : RelOptRule(
    OperandBuilderImpl.operand(
        config!!.operandSupplier()
    ),
    config!!.relBuilderFactory(), config!!.description()
) {
    /** Rule configuration.  */
    interface Config {
        /** Creates a rule that uses this configuration. Sub-class must override.  */
        fun toRule(): RelOptRule?

        /** Casts this configuration to another type, usually a sub-class.  */
        fun <T : Object?> `as`(class_: Class<T>): T {
            return if (class_.isAssignableFrom(this.getClass())) {
                class_.cast(this)
            } else {
                throw UnsupportedOperationException(
                    String.format(
                        Locale.ROOT,
                        "The current config of type %s is not an instance of %s.",
                        this.getClass(),
                        class_
                    )
                )
            }
        }

        /** The factory that is used to create a
         * [org.apache.calcite.tools.RelBuilder] during rule invocations.  */
        @Value.Default
        fun relBuilderFactory(): RelBuilderFactory? {
            return RelFactories.LOGICAL_BUILDER
        }

        /** Sets [.relBuilderFactory].  */
        fun withRelBuilderFactory(factory: RelBuilderFactory?): Config?

        /** Description of the rule instance.  */ // CALCITE-4831: remove the second nullable annotation once immutables/#1261 is fixed
        @Nullable
        fun description(): String?

        /** Sets [.description].  */
        fun withDescription(@Nullable description: String?): Config?

        /** Creates the operands for the rule instance.  */
        @Value.Default
        fun operandSupplier(): OperandTransform {
            return OperandTransform { s ->
                throw IllegalArgumentException(
                    "Rules must have at least one "
                            + "operand. Call Config.withOperandSupplier to specify them."
                )
            }
        }

        /** Sets [.operandSupplier].  */
        fun withOperandSupplier(transform: OperandTransform?): Config?
    }

    /** Function that creates an operand.
     *
     * @see Config.withOperandSupplier
     */
    @FunctionalInterface
    interface OperandTransform : Function<OperandBuilder?, Done?>

    /** Callback to create an operand.
     *
     * @see OperandTransform
     */
    interface OperandBuilder {
        /** Starts building an operand by specifying its class.
         * Call further methods on the returned [OperandDetailBuilder] to
         * complete the operand.  */
        fun <R : RelNode?> operand(relClass: Class<R>?): OperandDetailBuilder<R>?

        /** Supplies an operand that has been built manually.  */
        fun exactly(operand: RelOptRuleOperand?): Done?
    }

    /** Indicates that an operand is complete.
     *
     * @see OperandTransform
     */
    interface Done

    /** Add details about an operand, such as its inputs.
     *
     * @param <R> Type of relational expression
    </R> */
    interface OperandDetailBuilder<R : RelNode?> {
        /** Sets a trait of this operand.  */
        fun trait(trait: RelTrait?): OperandDetailBuilder<R>?

        /** Sets the predicate of this operand.  */
        fun predicate(predicate: Predicate<in R>?): OperandDetailBuilder<R>?

        /** Indicates that this operand has a single input.  */
        fun oneInput(transform: OperandTransform?): Done?

        /** Indicates that this operand has several inputs.  */
        fun inputs(vararg transforms: OperandTransform?): Done?

        /** Indicates that this operand has several inputs, unordered.  */
        fun unorderedInputs(vararg transforms: OperandTransform?): Done?

        /** Indicates that this operand takes any number or type of inputs.  */
        fun anyInputs(): Done?

        /** Indicates that this operand takes no inputs.  */
        fun noInputs(): Done?

        /** Indicates that this operand converts a relational expression to
         * another trait.  */
        fun convert(`in`: RelTrait?): Done?
    }

    /** Implementation of [OperandBuilder].  */
    private class OperandBuilderImpl : OperandBuilder {
        val operands: List<RelOptRuleOperand> = ArrayList()
        @Override
        override fun <R : RelNode?> operand(relClass: Class<R>?): OperandDetailBuilder<R> {
            return OperandDetailBuilderImpl(this, relClass)
        }

        @Override
        override fun exactly(operand: RelOptRuleOperand?): Done {
            operands.add(operand)
            return DoneImpl.INSTANCE
        }

        companion object {
            fun operand(transform: OperandTransform): RelOptRuleOperand {
                val b = OperandBuilderImpl()
                val done: Done = transform.apply(b)
                Objects.requireNonNull(done, "done")
                if (b.operands.size() !== 1) {
                    throw IllegalArgumentException(
                        "operand supplier must call one of "
                                + "the following methods: operand or exactly"
                    )
                }
                return b.operands[0]
            }
        }
    }

    /** Implementation of [OperandDetailBuilder].
     *
     * @param <R> Type of relational expression
    </R> */
    private class OperandDetailBuilderImpl<R : RelNode?> internal constructor(
        parent: OperandBuilderImpl?,
        relClass: Class<R>?
    ) : OperandDetailBuilder<R> {
        private val parent: OperandBuilderImpl
        private val relClass: Class<R>
        val inputBuilder = OperandBuilderImpl()

        @Nullable
        private var trait: RelTrait? = null
        private var predicate: Predicate<in R> = Predicate<in R> { r -> true }

        init {
            this.parent = Objects.requireNonNull(parent, "parent")
            this.relClass = Objects.requireNonNull(relClass, "relClass")
        }

        @Override
        override fun trait(trait: RelTrait?): OperandDetailBuilderImpl<R> {
            this.trait = Objects.requireNonNull(trait, "trait")
            return this
        }

        @Override
        override fun predicate(predicate: Predicate<in R>): OperandDetailBuilderImpl<R> {
            this.predicate = predicate
            return this
        }

        /** Indicates that there are no more inputs.  */
        fun done(childPolicy: RelOptRuleOperandChildPolicy?): Done {
            parent.operands.add(
                RelOptRuleOperand(
                    relClass, trait, predicate, childPolicy,
                    ImmutableList.copyOf(inputBuilder.operands)
                )
            )
            return DoneImpl.INSTANCE
        }

        @Override
        override fun convert(`in`: RelTrait?): Done {
            parent.operands.add(
                ConverterRelOptRuleOperand(relClass, `in`, predicate)
            )
            return DoneImpl.INSTANCE
        }

        @Override
        override fun noInputs(): Done {
            return done(RelOptRuleOperandChildPolicy.LEAF)
        }

        @Override
        override fun anyInputs(): Done {
            return done(RelOptRuleOperandChildPolicy.ANY)
        }

        @Override
        override fun oneInput(transform: OperandTransform): Done {
            val done: Done = transform.apply(inputBuilder)
            Objects.requireNonNull(done, "done")
            return done(RelOptRuleOperandChildPolicy.SOME)
        }

        @Override
        override fun inputs(vararg transforms: OperandTransform): Done {
            for (transform in transforms) {
                val done: Done = transform.apply(inputBuilder)
                Objects.requireNonNull(done, "done")
            }
            return done(RelOptRuleOperandChildPolicy.SOME)
        }

        @Override
        override fun unorderedInputs(vararg transforms: OperandTransform): Done {
            for (transform in transforms) {
                val done: Done = transform.apply(inputBuilder)
                Objects.requireNonNull(done, "done")
            }
            return done(RelOptRuleOperandChildPolicy.UNORDERED)
        }
    }

    /** Singleton instance of [Done].  */
    private enum class DoneImpl : Done {
        INSTANCE
    }

    /** Callback interface that helps you avoid creating sub-classes of
     * [RelRule] that differ only in implementations of
     * [.onMatch] method.
     *
     * @param <R> Rule type
    </R> */
    interface MatchHandler<R : RelOptRule?> : BiConsumer<R, RelOptRuleCall?>
}
